### Java内存区域

1. 程序计数器：程序计数器是当前线程所执行的行号指示器，代表当前线程所执行的下一条指令的内存地址，是线程私有的，是Java虚拟机规范中唯一一个没有OOM的地方
2. Java虚拟机栈：也是线程私有的，虚拟机栈代表了Java方法的线程内存模型，每个方法执行的时候，都会在虚拟机栈中创建一个栈帧，存放局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从执行到执行完毕，都对应了一个栈帧入栈和出栈的过程，其中局部变量表存放了编译器已知的各种基本数据类型、对象引用和returnAddress返回地址。而且在方法执行过程，所需内存在进入 方法就已经确定，运行期间不会改变局部变量表的大小。
3. 本地方法栈：和Java虚拟机栈一样，不过是为了本地方法服务，即C++方法
4. Java堆：用于存放Java对象，Java中几乎所有的对象都在堆上分配(逃逸分析: 栈上分配)，堆上一个重要的技术有TLAB：线程私有分配缓冲区，用于提升对象分配时的效率，解决线程之间的冲突问题。
5. 方法区：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等信息。在JDK8之前，方法区也叫永久代，但是其实这只不过是Hotspot的团队用永久代来实现方法区罢了，这样就不用专门为方法区编写垃圾收集。方法区的垃圾收集效率较低，但是也是必须收集的，不然很容易出现内存泄漏
   1. 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。这部分内容在类加载后存放到方法区的运行时常量池中。
6. 直接内存：不是虚拟机运行时数据区的一部分，也不是虚拟机规范中内存区域的一部分，但是这部分内存也会被频繁使用，同样会导致OOM，比如NIO可以通过Native函数直接在堆外分配内存，这样可以避免Java堆和Native堆来回复制数据所损耗的性能。



### 对象的创建

1. 当我们执行new指令时，首先检查new指令对应参数是否可以在运行时常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否已经被加载解析初始化，如果没有，就先执行对应的类加载过程
2. 为对象分配内存，有两种办法，一种是指针碰撞，即指针的一边是已用空间，一边是空闲空间，通过移动指针来控制内存，一种是空闲列表，即有一个列表来记录哪些地方是未分配的，选那种一般取决于所用的垃圾收集器，如果是采用标记整理或者复制算法的，一般采用指针碰撞，如果采用的是标记清除，一般采用空闲列表。同时分配对象时，需要修改指针指向的位置，这种情况需要考虑在并发的情况下线程安全的问题，可以通过CAS配上失败重试来保证更新操作的原子性来解决，但是Hotspot采用的是将内存按照线程划分为几个部分，即每个线程在Java堆中预先分配一小块内存，即TLAB，只有在TLAB用完时，才需要同步锁定。
3. 内存分配完成后，虚拟机必须将分配到的内存空间（不包括对象头）初始化为零值，保证对象的实例字段在不赋初始值的情况下就可以使用
4. 对生成的对象进行必要的设置，例如这个对象是哪个类的实例，对象的哈希码，元数据信息等，这些信息都存放在了对象头中
5. 在虚拟机的视角来看一个新的对象已经生成了，但是在Java程序的视角来看，对象的创建才刚刚开始，现在还需要执行对应的构造函数，即Class文件中的init方法。执行完构造函数后，一个对象就按照程序员的意愿进行了初始化，一个真正可用的对象才算完全构造出来

1. 

### 对象在堆中的内存布局

对象在堆上的布局分三个部分：对象头、实例数据、对齐填充。

其中对象头主要包含两个部分，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，偏向锁ID等，这部分也叫Mark Word，具体结构如下所示

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级的指针                     | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC标志             |
| 偏向线程ID、偏向时间戳，对象分代年龄 | 01     | 可偏向             |

对象头的另外一部分是类型指针，即对象指向它的类型元数据指针，虚拟机通过改指针来确定改对象是哪个类的实例，不过并不是所有的虚拟机实现都在对象数据上保留类型指针，意思就是查找对象不一定要经过对象本身，比如准确式GC。

接下来的实例数据就是存放对象真正有效信息的地方，即对象的各种内容。

第三部分是对齐指针，主要起占位符的作用，因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。

这里注意的一个点是对象的访问定位，主要有两种方法

1. 句柄访问：Java堆中划分出一块内存作为句柄池，reference中存放的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各种具体的地址，就类似一层中转
2. 直接指针访问，reference中存储的直接就是对象的地址，不需要句柄的多一次访问开销

两者的其实各有优劣，句柄最大的好处就是reference只存储句柄地址，在对象被移动时，只改变句柄中的指针，reference本身不需要修改，而指针指针的优点就是速度快，但是对象移动时，相应的也要修改reference中的地址，Hotspot采用的是直接指针