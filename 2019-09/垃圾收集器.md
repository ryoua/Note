# 垃圾收集器

###  Serial收集器

- Serial收集器是最基础、历史最悠久的收集器。该收集器是一个单线程工作的收集器，但它的"单线程"的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，     更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。"Stop The     World"这项工作是由虚拟机在后台自动发起和自动完成的，     在用户不可知、不可控的情况下把用户的正常工作的线程全部都停掉，这对很多应用来说都是不可接受的。
- 虽然有着以上的缺点，但它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），     对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory     Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，     专心做垃圾收集自然可以获得最高的单线程收集效率。

### ParNew收集器

- ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法Stop     The World、 对象分配规则、回收策略等都与Serial收集器完全一致。

注意

- 并行和并发都是并发编程中的专业名词，在谈论垃圾收集器的上下文语境中，它们可以理解为：

- - 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程处于等待状态。
  - 并发（Concurrent）：并发描述的是垃圾收集器与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以线程仍然能响应服务请求，      但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量收到一定影响。

### Parallel Scavenge收集器

- Parallel     Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。

- CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel     Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总耗时时间的比值，即：

- - 吞吐量 =      运行用户代码时间 / (运行用户代码时间 + 运行垃圾收集时间)

- 如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，     良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽可能完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

### Serial Old收集器

- Serial     Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也有可能有两种用途：     一种是在JDK5以及之前的版本中与Parallel     Scavenge收集器搭配使用，另一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### Parallel Old收集器

- Parallel     Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。该收集器是JDK6时才开始提供的。

### CMS收集器

- CMS（Concurrent     Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法实现的，它的运作过程分为四个步骤，包括：

- - 1）初始标记（CMS      initial mark）
  - 2）并发标记（CMS      concurrent mark）
  - 3）重新标记（CMS      remark）
  - 4）并发清除（CMSconcurrent      sweep）

- 其中初始标记、重新标记这两个步骤仍然需要"Stop     The World"。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC     Roots的直接关联对象开始遍历整个对象图的过程，     这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，     这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

- CMS收集器至少有以下三个明显的缺点：

- - 首先，CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算器的计算能力）而导致应用程序变慢，降低总吞吐量。      CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，当处理器核心数量不足4个时，CMS对用户程序的影响就可能变得很大。如果应用程序本来的处理器负载就很高，      还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓和这种情况，虚拟机提供了一种称为"增量式并发收集器"的CMS收集器变种，在并发标记、清理的时候让收集器线程、      用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间。
  - 然后，由于CMS收集器无法处理"浮动垃圾"（Floating      Grabage），有可能出现"Concurrent Mode Failure"失败进而导致另一次完全"Stop      The World"的Full GC的产生。在CMS的并发标记和并发清理阶段，      用户线程是还在继续运行的，程序在运行自然就还会伴随着有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为"浮动垃圾"。
  - 最后，CMS是一款基于"标记-清除"算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，      但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。

### G1收集器

- Garbage     First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。G1是一款主要面向服务端应用的垃圾收集器。

- 作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起"停顿时间模型"（Pause     Prediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，     消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java（RTSJ）的中软实时垃圾收集器特征了。

- 具体要实现这个目标，首先要有一个思想上的改变，在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor     GC），要么就是整个老年代（Major GC）， 再要么就是整个Java堆（Full     GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection     Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代， 而是哪块内存中存放的垃圾数量最多，回收效益最大，这就是G1收集器的Mixed     GC模式。

- G1开创的机油Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，     而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，     这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

- Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，     取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous     Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分进行看待。

- 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，     即每次收集到的内存空间都是Region大小的整倍数，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的"价值"大小，     价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的那些Region，这也就是"Garbage     First"名字的由来。     这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能的收集效率。

- 如果不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：

- - 初始标记（Initial      Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改了TAMS（Top at Mark      Start）指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。      这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
  - 并发标记（Concurrent      Marking）：从GC      Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。      当对象图扫描完成以后，还要重新处理STAB记录下来的在并发时有引用变动的对象。
  - 最终标记（Final      Marking）：对用户线程做另一个短暂暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
  - 筛选回收（Live      Data Counting and      Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行统计数据，对各个Region的回收价值和成本进行排序，      根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。      这里的操作涉及存活的对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

- 与CMS的"标记-清除"算法不同，G1从整体来看是基于"标记-整理"算法实现的收集器，但从局部（两个Region之间）上看是基于"标记-复制"算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，     垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

 